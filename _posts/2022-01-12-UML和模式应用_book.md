---
layout: post
title: "UML和模式应用"
author: "ShanDaMing"
tags: 软件
excerpt_separator: <!--more-->
---

## 绪论<!--more-->
面向对象分析和设计  -- OOA/D介绍
1. OO开发中，至关重要的能力是熟练的为软件对象分配职责。
2. 面向对象分析，强调的是在问题领域内发现和描述对象(或概念)
3. 面向对象设计，强调的是定义软件对象以什么及他们如何协作(发消息)以实现需求。
4. 定义用例 -> 定义领域模型 -> 分配对象职责并绘制交互图 -> 定义设计类图

迭代进化和敏捷
1. 开发周期被组织成一系列固定短期(如三个星期)小项目，称为迭代。
2. 多次迭代，进行持续扩展和精化，系统增量式的发展，循环反馈和设计进化。

## 初始阶段
初始不是需求阶段 -- 初始
1. 初始阶段的目标不是定义所有需求。
2. 预见项目的范围、设想、业务案例。

进化式需求
1. 需求就是系统必须提供的能力和必须遵从的条件
2. 用一种系统的方法来寻找、记录、组织和跟踪系统不断变更的需求。

用例
1. 用例是文本形式的情节描述，用例建模是用例的集合
2. 用例就是一组相关的成功和失败场景集合，用来描述参与者如何使用系统来实现其目标。
3. 用例模型还包括补充性规格说明，词汇表，设想，业务规则。
4. 用例就是需求
5. 用例的常用三种形式：摘要、非正式、详述。

其他需求
1. 补充性规格说明、词汇表、设想、业务规则

## 细化迭代1 基础
迭代1 基础 -- 迭代1需求
1. 迭代1的重点：基础范围、常见构架、风险驱动
2. 构建核心构架，解决高风险元素，定义大部分需求，预计总体进度和资源

领域模型 -- 领域建模
1. 确定当前迭代相关的概念类，创建领域模型
2. 为模型建立适当的属性和关联

系统顺序图
1. 系统顺序图是为阐述与所讨论系统相关的输入和输出事件而快速、简单创建的制品，是操作契约和对象设计的输入
2. 系统顺序图表示的是对于用例的一个特定场景，外部参与者产生的事件，其顺序和系统只内的事件，所有系统被视为黑盒，试图强调的是从参与者到系统的跨越系统边界的事件。

操作契约
1. 操作契约使用前置/后置条件，描述领域模型里的对象详细变化(断言)

从需求到设计 迭代进化

逻辑构架和UML包图 -- 逻辑构架
1. 逻辑构架是软件类的宏观组织结构，它将软件类组织为包(命名空间)，子系统和层
2. 使用层进行设计
3. 内聚职责，使关系分离
4. 不要将外部服务资源表示为最底层
5. 模型-视图分离原则

迈向对象设计
1. 绘图然后编码，交替进行。
2. 并行创建若干模型，先画交互图，在画类图，反复交替
3. 画图花费几小时或最多一天时间，对于有难度，有创造性的部分要详细设计。

4. 对象建模有2种类型。
	  * 动态模型(顺序图、通信图，状态机、活动图)，这是重要图形，应多花费时间在这上面，将职责驱动设计和GRASP原则应用到这上面
	  * 静态模型(包、类名、属性、函数，部署图)

5. 要用对象进行思考和设计，并应用对象设计的最佳实践模式。
6. 要弄清楚: 对象的职责是什么？对象在与谁协作交互，应该用什么设计模式，对象该分配哪些职责

UML交互图
1. 因为要考虑发送哪些消息，发送给谁，以何种顺序发送，所以要多花时间使用交互图进行动态建模
2. 认为生命线框图等同于类的实例并不十分精确，但在非正式和实践中，通常会这样解释这些参与者。

UML类图
1. 要区分领域模型概念透视图和设计类图
2. 设计类图关联线要有箭头，而领域模型概念图关联线不能有箭头。
3. 交互图与类图要并行创建，交互图先行。

GRASP基于职责设计对象 -- 使用GRASP的对象设计
1. 最关键的软件开发工具是受过良好设计原则训练的思维，而不是UML或其他技术。
2. 考虑怎样给协作中的对象分配职责。
3. 职责分为行为和认知
	 * 行为包括：
	  	- 自身执行一些行为，如创建对象或计算
	  	- 初始化其他对象中的动作
	  	- 控制和协调其他对象中的活动
	 * 认知职责包括：
		  - 对私有封装数据的认知
		  - 对相关对象的认知
		  - 对其能够导出或计算事物的认知
4. 绘制交互图是考虑分配职责(实现为方法)的时机
5. GRASP模式示例
	 * 创建者：谁创建了A？
		  + 如果有后面之一条件为真时，将创建类A实例的职责分配给类B。 
		   	- B包含或组成聚集了A
		   	- B记录A
		   	- B紧密的使用A
		   	- B具有A的初始化数据
	 * 信息专家：给对象分配职责的基本原则是什么？
		  + 把职责分配给具有完成该职责所需信息的那个类。
	 * 低耦合：如何减少因变化产生的影响？
		  + 分配职责以使耦合保持在较低的水平，用该原则对可选方案评估。
	 * 控制器：在UI层之上首先接收和协调系统操作的对象是什么？
		  + 把职责分配给能代表下列选择之一的对象。
			   - 代表全部系统、根对象、运行软件的设备或主要子系统(外观控制器的所有变体)
			   - 代表发生系统操作的用例场景(用例或会话控制器)
	 * 高内聚：怎样使对象保持有内聚、可理解、可管理，同时有支持低耦合的附加作用？
		  + 职责分配应保持高内聚，依此来评估备选方案
		
对可见性进行设计
1. 可见性是对象看到或引用其他对象的能力。
2. 可见性通常有4种:
	  * 属性可见性  B是A的属性
	  * 参数可见性  B是A中方法的参数
	  * 局部可见性  B是A中方法的局部对象
	  * 参数可见性  B具有某种方式的全局可见性
	  
将设计映射为代码
1. 实际在编成和测试中，可能会作出很多变更并发现和解决无数细节问题。
2. 类的实现顺序要按照从耦合度最低的到耦合度最高的来实现。

测试驱动开发和重构

## 细化迭代2 更多模式
迭代2:更多模式 -- 迭代2需求
1. 在迭代1结束时，软件应该都已经被充分的测试:单元、验收、负载、可用性
2. 参加新的需求讨论会议，编写需求用例，在细化过程中对10%最有风险的部分做详细设计和实现,并探讨定义80%的用例，这部分在后续迭代中实现。
3. 多次迭代对同一用例的不同场景或特性进行工作，并逐渐的扩展系统、增量的开发以实现对所有功能需求的处理。一次迭代应该完成一个或多个端到端的场景。

快速的更新份新 -- 迭代2分析
1. 建议举行1到2天的需求讨论会，调查和详细编写更多需求，分析先前的需求也可以进行精化。
2. 要多做设计建模。

GRASP：更多具有职责的对象
1. 多态：当相关选择或行为随类型而有所不同时，使用多态操作作为变化的行为类型分配职责
2. 纯虚构：凭空虚构一个类，分配给这虚构物的职责需要支持高内聚、低耦合(该类可能不代表问题领域的概念)。
	 * 此类对象可以分为2组
		  + 通过表示解析所产生的选择。 例如：TableOfContents目录对象其包含的信息应该与领域概念一致
		  + 通过行为解析所产生的选择   例如：TableOfContentsGenerator目录生成器对象就是个帮助类，目的是生成目录大纲。
3. 间接性：将职责分配给中介对象，让他做其他构建或服务之间的媒介，避免直接耦合，中介实现了其他构建之间的间接性。
	 * 面向对象设计中的大多数问题都可以通过增加一层间接性来解决。
	 * 大多数性能问题都可以通过去除一层间接性来解决。
4. 防止变异：识别预计变化或不稳定之处，分配职责用以在这些变化之外创建稳定的接口。这里的接口之的是广泛意义上的访问试图，而不仅仅是类接口。
	 * 这是最重要和基本的软件设计原则。
	 * 得墨忒耳定律(不要和陌生人说话): 不要经历远距离的对象结构路径取向远距离的间接对象发送消息。
	 * 信息隐藏：由于困难和可能的变化而对其他模块隐藏与设计相关的信息。
	 * 开放 - 封闭原则：模块应该同时(对扩展、可适应性)开放和(对影响客户的更改)封闭
应用GOF设计模式
1. 模式太多，要找到根本原则。
2. 适配器：将构建的原接口转换为其他接口
3. 工厂  --  原则：设计要保持关注分离
4. 单例
5. 策略：定义每种算法/政策/策略 -- 策略对象将依附于语境对象。将语境对象引用传递给策略
6. 组合 -- 可以解决冲突的策略 -- 原则：将聚合对象作为参数传递
7. 外观：定义唯一接触点，实用外观封装子系统，该外观提供唯一和统一接口。外观通常用单例实现
8. 观察者

## 细化迭代3 -- 中级主题
迭代3-中级主题 -- 迭代3需求
1. 探讨各种各样的分析和设计主题

UML活动图及其建模
1. 非常复杂业务中很有用，对于简单的业务用例文本就可以了。

UML状态机图和建模
1. 对象依赖对象对事件的响应根据对象的状态或模式而不同，则考虑建立状态机

用例关联
1. 不应该多花时间如何关联用例，而应该做好编写用例文本
2. 当2个或多个独立用例中存在重复，推荐用包含管关系
3. 优先使用包含关系
4. 扩展关系、泛化关系做补充。

领域模型的精化
1. 使用泛化、特化、关联类、时间间隔、组合和包装等概念精化领域模型
2. 要反复研究需求中的概念，增量的开发领域模型，如概念分类表，名词短语识别等技术
3. 识别本次迭代有关的超类(概念)和子类(概念)，在领域模型中阐明
	 * 概念超类定义必须100%适用于子类，子类必须100%与超类一致  -- 属性 关联
	 * Is-a 规则：子类集合的所有成员必须是其超类集合的成员
4. 将概念类划分为子类的重要动机：
	 * 子类有额外的有意义的属性
	 * 子类有额外的有意义的关联
	 * 子类概念的操作、处理、反映或使用的方式不同于其超类或其他子类，而这些方式是我们所关注的
	 * 子类概念表示了一个活动体(例如动物，机器人)，其行为与超类或者其他子类不同，而这些行为是我们所关注的
5. 识别出潜在子类的共性，将其泛化为公共超类(概念)
6. 抽象概念类：如果类C的每个成员也必须是某个子类的成员，则类C被称作抽象概念类
	 * 对变化的状态建模：不要将概念X的状态建模为X的子类有2个可供选择
		  + 定义状态类层次结构，并将其与类X关联
		  + 在领域模型中忽略概念的状态，而在状态图中加以反映。
7. 关联类：在领域模型中，如果类C可能同事有多个相同的属性A，则不要将属性A置于C之中，应该将属性A放到另一个类中，并将其与类C关联
	 * 在领域模型中增加关联类的可能线索有
		  + 有某个属性与关联相关
		  + 关联类的实例具有依赖于关联的生命周期
		  + 两个概念之间有多对多关联，并且存在与关连自身相关的信息。
8. 使用组合： 关于组合关系：如有疑问，仍在一边，
	 * 下述情形可以考虑使用组合关系
		  + 部分的生命周期在组成的生命周期界限之内，部分的创建和删除依赖于整体
		  + 在物理或逻辑组装上，整体的一部分关系和明确
		  + 组成的某些属性(例如位置)会传递给部分。
		  + 对组成的操作（例如销毁，移动和记录）可能传递给部分
9. 用包来组织领域模型
	 * 将领域模型划分为包结构时，将满足下述条件的元素当在一起
		  + 在同一个主题领域，概念或目标密切相关的元素
		  + 在同一个类层次结构中的关系
		  + 参与同一个用例的元素
		  + 有很强的关联性的元素
		  
更多的SSD和契约

架构分析
1. 架构分析早于第一次迭代，但也和迭代是齐头并进的
2. 定义变化点和进化点
	 * 变化点：当前现有系统或需求中的变化之处
	 * 进化点：现有需求中不存在，但可能在将来发生，推测性的变化点
3. 构架分析是在功能性需求的语境中，识别和处理系统非功能性需求的活动，其包括识别变化点和最具有可能的进化点
4. 构架分析常用方法
	 * 识别和分析对构建有影响的非功能性需求，这些被称为构架因素
	 * 对于这些在构架方面具有重要影响的需求，需要分析可供选择的办法并创建解决这些影响的解决方案，这是构架决策
5. 将构架因素并入补充规格说明里
6. 用技术备忘录记录构架选择、决策、动机
7. 基本的构架设计原则：低耦合、高内聚、防止变异、关注分离
	 * 关注分离的几个大尺度的技巧
		  + 将有关事物模块化，封装到单独的构件中，并且调用其服务
		  + 使用装饰者
		  + 使用后编译器和面向方面技术
		
逻辑构架的精化
1. 构架视图应该隐藏无关细节，强调构架设计师想传达的重点，
2. 构架逻辑视图中的交互图应该侧重于跨越层和包边界的交互，因此，描述具有重要构架意义的场景的一组交互图是有益的。
3. 构架性的层模式用来定义大尺度的分块，同事诸如外观、控制器、观察者这样的微观构架设计模式则用来设计层和包之间的连接

包的设计
1. 包在水平和垂直划分上的功能性内聚。最基本直观性的原则是基于功能性内聚的模块化，将参与共同目的、服务、协作、策略和功能的强相关类型组织在一起
2. 由一族接口组成的包。将一组共嫩上相关的接口放入单独的包，与其实现分离
3. 用于正式工作的包和用于聚集不稳定类的包。将不稳定的部分分离为单独的包，减少对不稳定包的广泛依赖。
4. 职责越多的包越需要稳定
	 * 有几种增强包稳定的方法
		  + 包中仅包含或者主要包含接口和抽象类
		  + 不依赖于其他的包，或者仅依赖非常稳定的包，或者封装了依赖关系以使其不受影响
		  + 包含相对稳定的代码，这些代码在发布之前经过充分的测试和精化
		  + 强制规定具有缓慢的变化周期
5. 将不相关的类型分离出去。将能够独立使用或运行于不同语境的类型组织到单独的包中
6. 使用工厂模式减少对具体包的依赖
7. 包之间没有循环依赖
	 * 有2个解决方案
		  + 将参与循环的类型分解出来形成较小的新包
		  + 使用接口来打破循环

实用GOF模式完成更多的对象设计
1. 异常最适合于处理资源（例如硬盘、内存、网络、数据库和其他外部服务）故障的情形
2. 异常指导准则：在一个子系统中，避免直接抛出来自较低层子系统或服务的异常，应该将较低层的异常转换成在本层次子系统中有意义的异常，较高层的异常包裹较低层的异常并添加一些信息，使得该异常在较高的子系统语境中有意义。
3. 异常类命名：对问题而不是抛出者命名
4. 集中错误日志：使用单例类访问集中错误日志对象，所有的异常和错误都向他报告。
5. 错误会话：使用单例向用户通知错误，他包裹一个或多个对象（包括GUI对话框、文本控制台、错误日志等），将职责委派给对象，用工厂读取系统参数并创建相应的对象，这样错误即可以传给GUI、控制台，也能传给错误日志对象。
6. 代理模式：通过代理对象增加一层间接性，代理对象实现与主题对象相同的接口，并负责控制和增强对主题对象的访问。

使用模式设计持久性框架
1. 好莱坞原则：不要给我们打电话，我们会打给你
2. 状态模式
	 * 语境/问题：对象的行为依赖于他的状态，而他的方法中包含能够反映依赖状态的条件动作的case逻辑。是否存在替代条件逻辑的方法？
	 * 解决方案：给每个状态创建状态类，并实现一个公共接口，将语境对象中的依赖于状态的操作委派给其当前的状态对象，确保语境对象总是指向反映其当前状态的状态对象。
3. 命令模式
	 * 语境/问题：如何处理需要诸如排序、优先级、派对、延迟、记录日志或重做等功能的请求或任务？
	 * 解决方案：为每一个任务创建一个类，并实现共同的接口
